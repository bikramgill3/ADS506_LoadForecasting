---
title: "ADS506 - Group Project - ERCOT Load Forecasting"
output: html_document
---

```{r setup, include=FALSE}
library(astsa)
library(ggplot2)
library(readxl)
library(tidyverse)
library(ggdark)
library(reshape2) 
library(xts)
```


####### Need to add Travis' Comments in for these code blocks! #################


```{r dataload}
load17.df <- read_excel('Native_Load_2017.xlsx')
load18.df <- read_excel('Native_Load_2018.xlsx')
load19.df <- read_excel('Native_Load_2019.xlsx')
load20.df <- read_excel('Native_Load_2020.xlsx')
load21.df <- read_excel('Native_Load_2021.xlsx')
```


```{r dataprep}
## The load dataset for 2017 had a space in the Timestamp column, preventing the binding of the four years
colnames(load17.df)[1] <- "HourEnding"

## Using bind_rows from tidyverse, I merged 2017-2020
load_4_year <- bind_rows(load17.df,load18.df,load19.df,load20.df)
sum(is.na(load_4_year))


## Using strptime, I converted the time column to a date variable
load_4_year$HourEnding <- as.POSIXct(strptime(load_4_year$HourEnding, format="%m/%d/%Y %H:%M"))

#load_4_year$HourEnding <- as.Date(load_4_year$HourEnding, format="%m/%d/%Y %H:%M") ## removed this to retain hourly info for plot

class(load_4_year$HourEnding)
head(load_4_year)
sum(is.na(load_4_year))

#Remove NA's which arise due to issues with daylight savings (1 record in each year)
load_4_year <- na.omit(load_4_year)


## Converting to a time series
ts_load <- xts(load_4_year, load_4_year$HourEnding)
ts_load <- ts_load[,-1]
head(ts_load)
```






```{r plotfunction, message=FALSE}


### This is a sample of what we could do in ggplot, although may look a bit ugly because of the cyclical nature of our time series (i.e. there are daily power cycles, which over 4 years and many regions doesn't come out that well)

plot_data = function(df, title){
  
  plot_melt = melt(df, na.rm = FALSE, value.name = 'Load', id = 'HourEnding')
  names(plot_melt)[2] <- "Region"

  plt = ggplot(data = plot_melt, mapping = aes(x=HourEnding, y=Load, colour = Region)) +
  geom_line(size = 0.1, alpha=0.4) +
  ggdark::dark_mode() + 
  theme(legend.position = 'bottom', ) + 
  ggtitle('ERCOT Actual Power Load by Region - ' , title) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylab("Electrical Load (MW)") +
  xlab("Hour Ending") +
  theme(panel.grid.major = element_blank()) +
  guides(shape = guide_legend(override.aes = list(size = 1)),
               color = guide_legend(override.aes = list(size = 1))) +
  theme(legend.title = element_text(size = 8), 
              legend.text  = element_text(size = 8),
              legend.key.size = unit(1, "lines"))
    
  return(plt)}

plot_data(load_4_year, 'Raw Data')
```

```{r standardization, message=FALSE}
library(dplyr)

### So basically all we need to do now, make the transformation to load_4_year, and pass to the function with a new title!

std = load_4_year %>%
  mutate_if(is.numeric, scale)

plot_data(std, 'Standardized')
```


```{r differencing, message=FALSE}
### Applying differencing and detrending to remove seasonality and make data stationary:

df2 = as.numeric(as.character(unlist(load_4_year)))

### Applying a single differencing:
dload = diff(df2, lag = 2, differences = 1 )

fit = lm(load_4_year, na.action=NULL) # the regression
par(mfrow=c(2,1)) # plot transformed data
tsplot(resid(fit), main="Detrended ERCOT Actual Power Load by Region")
tsplot(dload, main="ERCOT Actual Power Load by Region")
```


```{r}
# Jack Box-cox transformation

library(EnvStats)

set.seed(250) 

dev.new()
qqPlot(boxcoxTransform(load_4_year$ERCOT, lambda = 0.5), add.line = TRUE) 

dev.new()
qqPlot(boxcoxTransform(load_4_year$ERCOT, lambda = 0), add.line = TRUE)

dev.new()
qqPlot(boxcoxTransform(as.numeric(ts_load$ERCOT), lambda = 0.5), add.line = TRUE)

dev.new()
qqPlot(boxcoxTransform(as.numeric(ts_load$HourEnding), lambda = 0), add.line = TRUE)

dev.new()
qqPlot(boxcoxTransform(as.numeric(ts_load$HourEnding), lambda = 0.5), add.line = TRUE)
```

```{r Normalization, message=FALSE}
## Building out the min/max scaler to normalize the data as a function
normalize <- function(x) {
 (x-min(x))/(max(x)-min(x))
}

## Removing the POSIXlt column to normalize
loadnorm <- (load_4_year[,-1])

## Running the new DF through the normalization function
loadnorm <- normalize(loadnorm)

## Adding the POSIXlt column back on
loadnorm["HourEnding"] <- load_4_year$HourEnding

## Plotting the data
plot_data(loadnorm, "Normalized (Min/Max")
```
It is clear that a min max normalization scalar is not a usable option as it does not account for the mean. The graph is still visually the same.

